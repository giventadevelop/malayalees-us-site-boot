<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>AWS Deployment Architecture Guide - Updated (Fargate/EKS)</title>
    <script src="https://cdn.jsdelivr.net/npm/mermaid/dist/mermaid.min.js"></script>
    <style>
        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            max-width: 1200px;
            margin: 0 auto;
            padding: 20px;
            background-color: #f8f9fa;
            line-height: 1.6;
        }
        .container {
            background: white;
            padding: 30px;
            border-radius: 10px;
            box-shadow: 0 4px 6px rgba(0,0,0,0.1);
        }
        h1 {
            color: #2c3e50;
            text-align: center;
            border-bottom: 3px solid #3498db;
            padding-bottom: 20px;
            margin-bottom: 30px;
        }
        h2 {
            color: #34495e;
            border-bottom: 2px solid #3498db;
            padding-bottom: 10px;
            margin-top: 40px;
        }
        h3 {
            color: #2c3e50;
            margin-top: 30px;
        }
        h4 {
            color: #34495e;
            margin-top: 25px;
        }
        .diagram-container {
            background: #f8f9fa;
            margin: 20px 0;
            padding: 20px;
            border-radius: 8px;
            border: 1px solid #e9ecef;
        }
        .mermaid {
            text-align: center;
            margin: 20px 0;
        }
        table {
            width: 100%;
            border-collapse: collapse;
            margin: 20px 0;
        }
        th, td {
            border: 1px solid #ddd;
            padding: 12px;
            text-align: left;
        }
        th {
            background-color: #3498db;
            color: white;
        }
        tr:nth-child(even) {
            background-color: #f2f2f2;
        }
        code {
            background-color: #f4f4f4;
            padding: 2px 4px;
            border-radius: 3px;
            font-family: 'Courier New', monospace;
        }
        pre {
            background-color: #f4f4f4;
            padding: 15px;
            border-radius: 5px;
            overflow-x: auto;
            border-left: 4px solid #3498db;
        }
        .pros-cons {
            display: flex;
            gap: 20px;
            margin: 20px 0;
        }
        .pros, .cons {
            flex: 1;
            padding: 15px;
            border-radius: 5px;
        }
        .pros {
            background-color: #d4edda;
            border-left: 4px solid #28a745;
        }
        .cons {
            background-color: #f8d7da;
            border-left: 4px solid #dc3545;
        }
        .highlight {
            background-color: #fff3cd;
            padding: 15px;
            border-radius: 5px;
            border-left: 4px solid #ffc107;
            margin: 20px 0;
        }
        .cost-savings {
            background-color: #d1ecf1;
            padding: 15px;
            border-radius: 5px;
            border-left: 4px solid #17a2b8;
            margin: 20px 0;
        }
        .toc {
            background-color: #e9ecef;
            padding: 20px;
            border-radius: 5px;
            margin: 20px 0;
        }
        .toc ul {
            list-style-type: none;
            padding-left: 0;
        }
        .toc li {
            margin: 5px 0;
        }
        .toc a {
            text-decoration: none;
            color: #3498db;
        }
        .toc a:hover {
            text-decoration: underline;
        }
        .version-info {
            background-color: #f8f9fa;
            padding: 15px;
            border-radius: 5px;
            border-left: 4px solid #6c757d;
            margin: 20px 0;
            font-style: italic;
        }
        .benefits-list {
            background-color: #d4edda;
            padding: 15px;
            border-radius: 5px;
            border-left: 4px solid #28a745;
            margin: 20px 0;
        }
        .warning-list {
            background-color: #fff3cd;
            padding: 15px;
            border-radius: 5px;
            border-left: 4px solid #ffc107;
            margin: 20px 0;
        }
        .phase-box {
            background-color: #e7f3ff;
            padding: 15px;
            border-radius: 5px;
            border-left: 4px solid #007bff;
            margin: 20px 0;
        }
        .phase-box h4 {
            margin-top: 0;
            color: #007bff;
        }
        .summary-box {
            background-color: #f8f9fa;
            padding: 20px;
            border-radius: 5px;
            border-left: 4px solid #6c757d;
            margin: 20px 0;
        }
        .summary-box h4 {
            margin-top: 0;
            color: #495057;
        }
        .summary-box ul {
            margin: 10px 0;
        }
        .summary-box li {
            margin: 5px 0;
        }
    </style>
</head>
<body>
    <div class="container">
        <h1>AWS Deployment Architecture Guide - Updated (Fargate/EKS)</h1>
        <h2>Multi-Tenant Spring Boot Application</h2>

        <div class="toc">
            <h3>Table of Contents</h3>
            <ul>
                <li><a href="#overview">1. Overview</a></li>
                <li><a href="#architecture-comparison">2. Architecture Comparison</a></li>
                <li><a href="#recommended-architecture">3. Recommended Architecture: Fargate</a></li>
                <li><a href="#alternative-eks">4. Alternative: EKS</a></li>
                <li><a href="#local-development">5. Local Development & Testing</a></li>
                <li><a href="#cost-comparison">6. Cost Comparison</a></li>
                <li><a href="#migration-strategy">7. Migration Strategy</a></li>
            </ul>
        </div>

        <section id="overview">
            <h2>Overview</h2>
            <p>Based on your feedback, here are the <strong>three deployment options</strong> with automation levels:</p>

            <table>
                <tr>
                    <th>Option</th>
                    <th>Automation Level</th>
                    <th>Cost</th>
                    <th>Maintenance</th>
                    <th>Best For</th>
                </tr>
                <tr>
                    <td><strong>EC2 + Auto Scaling</strong></td>
                    <td>Medium</td>
                    <td>Medium</td>
                    <td>Medium</td>
                    <td>Traditional workloads</td>
                </tr>
                <tr>
                    <td><strong>Fargate</strong></td>
                    <td>High</td>
                    <td>Low-Medium</td>
                    <td>Low</td>
                    <td>Serverless containers</td>
                </tr>
                <tr>
                    <td><strong>EKS</strong></td>
                    <td>Very High</td>
                    <td>Medium-High</td>
                    <td>Very Low</td>
                    <td>Microservices, advanced orchestration</td>
                </tr>
            </table>
        </section>

        <section id="architecture-comparison">
            <h2>Architecture Comparison</h2>

            <h3>Option 1: EC2 + Auto Scaling (Original)</h3>
            <div class="diagram-container">
                <div class="mermaid">
graph TB
    ALB[Application Load Balancer]
    ASG[Auto Scaling Group]
    EC2A[EC2 Instance 1]
    EC2B[EC2 Instance 2]
    RDS[RDS PostgreSQL<br/>with Built-in Caching]

    ALB --> ASG
    ASG --> EC2A
    ASG --> EC2B
    EC2A --> RDS
    EC2B --> RDS
                </div>
            </div>

            <div class="pros-cons">
                <div class="pros">
                    <strong>Pros:</strong> Full control, predictable costs, simplified architecture
                </div>
                <div class="cons">
                    <strong>Cons:</strong> More management overhead, manual scaling
                </div>
            </div>

            <h3>Option 2: Fargate (Recommended)</h3>
            <div class="diagram-container">
                <div class="mermaid">
graph TB
    ALB[Application Load Balancer]
    ECS[ECS Fargate Cluster]
    TASK1[Fargate Task 1]
    TASK2[Fargate Task 2]
    RDS[RDS PostgreSQL<br/>with Built-in Caching]

    ALB --> ECS
    ECS --> TASK1
    ECS --> TASK2
    TASK1 --> RDS
    TASK2 --> RDS
                </div>
            </div>

            <div class="pros-cons">
                <div class="pros">
                    <strong>Pros:</strong> No server management, auto-scaling, pay-per-use, simplified architecture
                </div>
                <div class="cons">
                    <strong>Cons:</strong> Less control over underlying infrastructure
                </div>
            </div>

            <h3>Option 3: EKS (Advanced)</h3>
            <div class="diagram-container">
                <div class="mermaid">
graph TB
    ALB[Application Load Balancer]
    EKS[EKS Cluster]
    NODE1[Worker Node 1]
    NODE2[Worker Node 2]
    POD1[Pod 1]
    POD2[Pod 2]
    RDS[RDS PostgreSQL<br/>with Built-in Caching]

    ALB --> EKS
    EKS --> NODE1
    EKS --> NODE2
    NODE1 --> POD1
    NODE2 --> POD2
    POD1 --> RDS
    POD2 --> RDS
                </div>
            </div>

            <div class="pros-cons">
                <div class="pros">
                    <strong>Pros:</strong> Kubernetes ecosystem, advanced orchestration, simplified architecture
                </div>
                <div class="cons">
                    <strong>Cons:</strong> Higher complexity, steeper learning curve
                </div>
            </div>
        </section>

        <section id="recommended-architecture">
            <h2>Recommended Architecture: Fargate</h2>

            <h3>Why Fargate is Better for Your Use Case</h3>
            <div class="highlight">
                <ul>
                    <li>✅ <strong>Fully Automated</strong>: No server management required</li>
                    <li>✅ <strong>Cost Effective</strong>: Pay only for running containers</li>
                    <li>✅ <strong>Auto Scaling</strong>: Built-in container scaling</li>
                    <li>✅ <strong>Zero Maintenance</strong>: AWS handles infrastructure</li>
                    <li>✅ <strong>Fast Deployment</strong>: Containers start in seconds</li>
                    <li>✅ <strong>Security</strong>: Isolated containers, no shared infrastructure</li>
                    <li>✅ <strong>Simplified Architecture</strong>: PostgreSQL built-in caching eliminates Redis dependency</li>
                </ul>
            </div>

            <h3>PostgreSQL Built-in Caching Features</h3>
            <p>PostgreSQL provides several built-in caching mechanisms that can effectively replace Redis:</p>

            <h4>1. Shared Buffers Cache</h4>
            <ul>
                <li><strong>Purpose</strong>: Caches frequently accessed data pages in memory</li>
                <li><strong>Configuration</strong>: <code>shared_buffers = 2GB</code> (25% of total RAM)</li>
                <li><strong>Benefits</strong>: Reduces disk I/O, improves query performance</li>
                <li><strong>Use Case</strong>: Replaces Redis for frequently accessed data</li>
            </ul>

            <h4>2. UNLOGGED Tables for Application Cache</h4>
            <ul>
                <li><strong>Purpose</strong>: Fast key-value storage without WAL overhead</li>
                <li><strong>Configuration</strong>:</li>
            </ul>
            <pre><code>CREATE UNLOGGED TABLE app_cache (
    cache_key TEXT PRIMARY KEY,
    cache_value TEXT,
    expires_at TIMESTAMP,
    created_at TIMESTAMP DEFAULT NOW()
);</code></pre>
            <ul>
                <li><strong>Benefits</strong>: Faster writes than regular tables, perfect for cache data</li>
                <li><strong>Use Case</strong>: Replaces Redis for Spring Cache and session storage</li>
            </ul>

            <h4>3. Materialized Views for Complex Queries</h4>
            <ul>
                <li><strong>Purpose</strong>: Pre-computed query results for complex aggregations</li>
                <li><strong>Configuration</strong>:</li>
            </ul>
            <pre><code>CREATE MATERIALIZED VIEW tenant_stats AS
SELECT tenant_id, COUNT(*) as user_count,
       MAX(created_at) as last_activity
FROM user_profile
GROUP BY tenant_id;</code></pre>
            <ul>
                <li><strong>Benefits</strong>: Instant access to complex query results</li>
                <li><strong>Use Case</strong>: Replaces Redis for expensive query result caching</li>
            </ul>

            <h4>4. Query Result Cache (PostgreSQL 14+)</h4>
            <ul>
                <li><strong>Purpose</strong>: Caches query results in memory</li>
                <li><strong>Configuration</strong>: <code>shared_preload_libraries = 'pg_stat_statements'</code></li>
                <li><strong>Benefits</strong>: Automatic caching of repeated queries</li>
                <li><strong>Use Case</strong>: Replaces Redis for query result caching</li>
            </ul>

            <h4>5. Connection Pooling with PgBouncer</h4>
            <ul>
                <li><strong>Purpose</strong>: Efficient connection management</li>
                <li><strong>Configuration</strong>: Built into RDS Proxy or custom PgBouncer</li>
                <li><strong>Benefits</strong>: Reduces connection overhead, improves performance</li>
                <li><strong>Use Case</strong>: Replaces Redis connection pooling benefits</li>
            </ul>

            <h3>Updated Cost Analysis (Fargate with PostgreSQL Caching)</h3>

            <h4>Phase 1: Initial (10 domains, 1K users)</h4>
            <div class="cost-savings">
                <ul>
                    <li>ECS Fargate: 2 tasks × 0.5 vCPU × 1GB RAM = ~$30/month</li>
                    <li>RDS PostgreSQL: db.t3.micro Multi-AZ = ~$25/month</li>
                    <li>Application Load Balancer = ~$25/month</li>
                    <li><strong>Total: ~$80/month</strong> (vs $95 with Redis, $125 for EC2)</li>
                    <li><strong>Savings: $15/month (16% reduction)</strong> vs Redis architecture</li>
                </ul>
            </div>

            <h4>Phase 2: Growth (50 domains, 10K users)</h4>
            <div class="cost-savings">
                <ul>
                    <li>ECS Fargate: 3-5 tasks × 1 vCPU × 2GB RAM = ~$60-100/month</li>
                    <li>RDS PostgreSQL: db.t3.small Multi-AZ = ~$50/month</li>
                    <li>Application Load Balancer = ~$25/month</li>
                    <li><strong>Total: ~$135-175/month</strong> (vs $165-205 with Redis, $200 for EC2)</li>
                    <li><strong>Savings: $30/month (18% reduction)</strong> vs Redis architecture</li>
                </ul>
            </div>

            <h4>Phase 3: Scale (100+ domains, 100K+ users)</h4>
            <div class="cost-savings">
                <ul>
                    <li>ECS Fargate: 5-10 tasks × 2 vCPU × 4GB RAM = ~$200-400/month</li>
                    <li>RDS PostgreSQL: db.t3.medium + Read Replica = ~$100/month</li>
                    <li>Application Load Balancer = ~$25/month</li>
                    <li><strong>Total: ~$325-525/month</strong> (vs $385-585 with Redis, $300-500 for EC2)</li>
                    <li><strong>Savings: $60/month (16% reduction)</strong> vs Redis architecture</li>
                </ul>
            </div>

            <h4>Cost Benefits Summary</h4>
            <ul>
                <li><strong>Eliminated Redis/ElastiCache</strong>: $15-60/month savings</li>
                <li><strong>Reduced Complexity</strong>: No Redis management overhead</li>
                <li><strong>Simplified Architecture</strong>: Single database dependency</li>
                <li><strong>Better Resource Utilization</strong>: PostgreSQL handles both data and caching</li>
            </ul>

            <h3>Fargate Configuration</h3>
            <pre><code># Fargate Task Definition
TaskDefinition:
  Family: malayalees-app
  NetworkMode: awsvpc
  RequiresCompatibilities: FARGATE
  Cpu: 512          # 0.5 vCPU
  Memory: 1024      # 1 GB RAM
  ExecutionRoleArn: arn:aws:iam::account:role/ecsTaskExecutionRole
  TaskRoleArn: arn:aws:iam::account:role/ecsTaskRole
  ContainerDefinitions:
    - Name: app
      Image: 123456789012.dkr.ecr.us-east-1.amazonaws.com/malayalees-app:latest
      PortMappings:
        - ContainerPort: 8080
          Protocol: tcp
      Environment:
        - Name: SPRING_PROFILES_ACTIVE
          Value: prod-aws-postgres-cache
        - Name: RDS_ENDPOINT
          Value: your-rds-endpoint.rds.amazonaws.com
        - Name: DB_NAME
          Value: malayalees_us_site
        - Name: CACHE_TYPE
          Value: postgresql
        - Name: POSTGRES_CACHE_TABLE
          Value: app_cache
      Secrets:
        - Name: DB_PASSWORD
          ValueFrom: arn:aws:secretsmanager:region:account:secret:db-password
      LogConfiguration:
        LogDriver: awslogs
        Options:
          awslogs-group: /ecs/malayalees-app
          awslogs-region: us-east-1
          awslogs-stream-prefix: ecs</code></pre>

            <h3>PostgreSQL Configuration for Caching</h3>
            <pre><code># RDS Parameter Group Configuration
ParameterGroup:
  Family: postgres13
  Parameters:
    # Shared Buffers - 25% of total memory
    - Name: shared_buffers
      Value: "2GB"
    # Effective Cache Size - 75% of total memory
    - Name: effective_cache_size
      Value: "6GB"
    # Work Memory for complex queries
    - Name: work_mem
      Value: "64MB"
    # Maintenance Work Memory
    - Name: maintenance_work_mem
      Value: "512MB"
    # Enable query statistics
    - Name: shared_preload_libraries
      Value: "pg_stat_statements"
    # Connection settings
    - Name: max_connections
      Value: "200"
    - Name: shared_preload_libraries
      Value: "pg_stat_statements"</code></pre>

            <h3>Application Configuration for PostgreSQL Caching</h3>
            <pre><code># src/main/resources/config/application-prod-aws-postgres-cache.yml
spring:
  profiles:
    active: prod-aws-postgres-cache

  datasource:
    url: jdbc:postgresql://${RDS_ENDPOINT}:5432/${DB_NAME}
    username: ${DB_USERNAME}
    password: ${DB_PASSWORD}
    hikari:
      maximum-pool-size: 20
      minimum-idle: 5
      connection-timeout: 30000
      idle-timeout: 600000
      max-lifetime: 1800000

  # PostgreSQL-based Caching Configuration
  cache:
    type: postgresql
    postgresql:
      cache-table: ${POSTGRES_CACHE_TABLE:app_cache}
      time-to-live: 600000 # 10 minutes
      cache-null-values: false
      enable-statistics: true

  # Session Management with PostgreSQL
  session:
    store-type: postgresql
    postgresql:
      table-name: "session_store"
      cleanup-cron: "0 0 * * * *" # Every hour

  # JPA/Hibernate with PostgreSQL caching
  jpa:
    properties:
      hibernate:
        cache:
          use_second_level_cache: true
          use_query_cache: true
          region:
            factory_class: org.hibernate.cache.jcache.JCacheRegionFactory
        connection:
          provider_disables_autocommit: true</code></pre>
        </section>

        <section id="alternative-eks">
            <h2>Alternative: EKS</h2>

            <h3>When to Choose EKS</h3>
            <div class="benefits-list">
                <ul>
                    <li>✅ <strong>Microservices Architecture</strong>: Multiple services</li>
                    <li>✅ <strong>Advanced Orchestration</strong>: Complex deployments</li>
                    <li>✅ <strong>Kubernetes Ecosystem</strong>: Helm, Istio, etc.</li>
                    <li>✅ <strong>Team Expertise</strong>: Kubernetes knowledge available</li>
                    <li>✅ <strong>Multi-Cloud</strong>: Portability across clouds</li>
                </ul>
            </div>

            <h3>EKS Configuration</h3>
            <pre><code># Kubernetes Deployment
apiVersion: apps/v1
kind: Deployment
metadata:
  name: malayalees-app
spec:
  replicas: 3
  selector:
    matchLabels:
      app: malayalees-app
  template:
    metadata:
      labels:
        app: malayalees-app
    spec:
      containers:
      - name: app
        image: 123456789012.dkr.ecr.us-east-1.amazonaws.com/malayalees-app:latest
        ports:
        - containerPort: 8080
        env:
        - name: SPRING_PROFILES_ACTIVE
          value: "prod-aws"
        resources:
          requests:
            memory: "512Mi"
            cpu: "250m"
          limits:
            memory: "1Gi"
            cpu: "500m"
        livenessProbe:
          httpGet:
            path: /management/health
            port: 8080
          initialDelaySeconds: 60
          periodSeconds: 30
        readinessProbe:
          httpGet:
            path: /management/health
            port: 8080
          initialDelaySeconds: 30
          periodSeconds: 10</code></pre>
        </section>

        <section id="local-development">
            <h2>Local Development & Testing</h2>

            <h3>Complete Local Testing Environment</h3>

            <h4>1. Docker Compose for Local Testing</h4>
            <pre><code># docker-compose.local.yml
version: '3.8'

services:
  # PostgreSQL Database with Caching Configuration
  postgres:
    image: postgres:15
    environment:
      POSTGRES_DB: malayalees_us_site
      POSTGRES_USER: postgres
      POSTGRES_PASSWORD: password
    ports:
      - "5432:5432"
    volumes:
      - postgres_data:/var/lib/postgresql/data
      - ./init-scripts:/docker-entrypoint-initdb.d
      - ./postgresql.conf:/etc/postgresql/postgresql.conf
    command: ["postgres", "-c", "config_file=/etc/postgresql/postgresql.conf"]
    healthcheck:
      test: ["CMD-SHELL", "pg_isready -U postgres"]
      interval: 10s
      timeout: 5s
      retries: 5

  # Spring Boot Application
  app:
    build:
      context: .
      dockerfile: Dockerfile.local
    ports:
      - "8080:8080"
    environment:
      SPRING_PROFILES_ACTIVE: local-postgres-cache
      RDS_ENDPOINT: postgres
      DB_NAME: malayalees_us_site
      DB_USERNAME: postgres
      DB_PASSWORD: password
      CACHE_TYPE: postgresql
      POSTGRES_CACHE_TABLE: app_cache
    depends_on:
      postgres:
        condition: service_healthy
    volumes:
      - ./logs:/var/log/spring-boot-app

  # pgAdmin (Optional - Database Management)
  pgadmin:
    image: dpage/pgadmin4
    environment:
      PGADMIN_DEFAULT_EMAIL: admin@local.com
      PGADMIN_DEFAULT_PASSWORD: admin
    ports:
      - "5050:80"
    depends_on:
      - postgres

volumes:
  postgres_data:</code></pre>

            <h4>2. PostgreSQL Configuration for Local Development</h4>
            <pre><code># postgresql.conf
# Memory Configuration for Caching
shared_buffers = 256MB                    # 25% of 1GB
effective_cache_size = 768MB              # 75% of 1GB
work_mem = 16MB                           # For complex queries
maintenance_work_mem = 128MB              # For maintenance operations

# Connection Settings
max_connections = 100
shared_preload_libraries = 'pg_stat_statements'

# Logging for Development
log_statement = 'all'
log_min_duration_statement = 1000
log_line_prefix = '%t [%p]: [%l-1] user=%u,db=%d,app=%a,client=%h '

# Performance Settings
random_page_cost = 1.1
effective_io_concurrency = 200</code></pre>

            <h4>3. Local Dockerfile</h4>
            <pre><code># Dockerfile.local
FROM openjdk:11-jre-slim

WORKDIR /app

# Copy the JAR file
COPY target/*.jar app.jar

# Create logs directory
RUN mkdir -p /var/log/spring-boot-app

EXPOSE 8080

# Health check
HEALTHCHECK --interval=30s --timeout=10s --start-period=60s --retries=3 \
    CMD curl -f http://localhost:8080/management/health || exit 1

ENTRYPOINT ["java", "-jar", "app.jar"]</code></pre>

            <h4>4. Local Configuration</h4>
            <pre><code># src/main/resources/config/application-local-postgres-cache.yml
spring:
  profiles:
    active: local-postgres-cache

  datasource:
    url: jdbc:postgresql://${RDS_ENDPOINT:localhost}:5432/${DB_NAME:malayalees_us_site}
    username: ${DB_USERNAME:postgres}
    password: ${DB_PASSWORD:password}
    hikari:
      maximum-pool-size: 10
      minimum-idle: 2
      connection-timeout: 30000
      idle-timeout: 600000
      max-lifetime: 1800000

  # PostgreSQL-based Caching Configuration
  cache:
    type: postgresql
    postgresql:
      cache-table: ${POSTGRES_CACHE_TABLE:app_cache}
      time-to-live: 600000 # 10 minutes
      cache-null-values: false
      enable-statistics: true

  # Session Management with PostgreSQL
  session:
    store-type: postgresql
    postgresql:
      table-name: "session_store"
      cleanup-cron: "0 0 * * * *" # Every hour

  # JPA/Hibernate with PostgreSQL caching
  jpa:
    hibernate:
      ddl-auto: update
      cache:
        use_second_level_cache: true
        use_query_cache: true
        region:
          factory_class: org.hibernate.cache.jcache.JCacheRegionFactory
    show-sql: true
    properties:
      hibernate:
        connection:
          provider_disables_autocommit: true

  liquibase:
    enabled: true
    contexts: local-postgres-cache

server:
  port: 8080

logging:
  level:
    ROOT: INFO
    com.nextjstemplate: DEBUG
    org.hibernate.SQL: DEBUG
    org.hibernate.cache: DEBUG
  pattern:
    console: "%d{yyyy-MM-dd HH:mm:ss} [%thread] %-5level %logger{36} - %msg%n"

management:
  endpoints:
    web:
      exposure:
        include: health,info,metrics,cache
  cache:
    cache-manager: postgresqlCacheManager</code></pre>

            <h4>5. PostgreSQL Caching Setup Scripts</h4>
            <pre><code>-- src/main/resources/init-scripts/02-postgres-cache-setup.sql
-- Create application cache table
CREATE UNLOGGED TABLE IF NOT EXISTS app_cache (
    cache_key TEXT PRIMARY KEY,
    cache_value TEXT NOT NULL,
    expires_at TIMESTAMP NOT NULL,
    created_at TIMESTAMP DEFAULT NOW(),
    updated_at TIMESTAMP DEFAULT NOW()
);

-- Create session store table
CREATE TABLE IF NOT EXISTS session_store (
    session_id VARCHAR(255) PRIMARY KEY,
    session_data BYTEA,
    last_access_time TIMESTAMP DEFAULT NOW(),
    max_inactive_interval INTEGER DEFAULT 1800
);

-- Create indexes for performance
CREATE INDEX IF NOT EXISTS idx_app_cache_expires_at ON app_cache(expires_at);
CREATE INDEX IF NOT EXISTS idx_session_store_last_access ON session_store(last_access_time);

-- Create cache cleanup function
CREATE OR REPLACE FUNCTION cleanup_expired_cache()
RETURNS INTEGER AS $$
DECLARE
    deleted_count INTEGER;
BEGIN
    DELETE FROM app_cache WHERE expires_at < NOW();
    GET DIAGNOSTICS deleted_count = ROW_COUNT;
    RETURN deleted_count;
END;
$$ LANGUAGE plpgsql;

-- Create session cleanup function
CREATE OR REPLACE FUNCTION cleanup_expired_sessions()
RETURNS INTEGER AS $$
DECLARE
    deleted_count INTEGER;
BEGIN
    DELETE FROM session_store
    WHERE last_access_time < NOW() - INTERVAL '1 hour' * max_inactive_interval;
    GET DIAGNOSTICS deleted_count = ROW_COUNT;
    RETURN deleted_count;
END;
$$ LANGUAGE plpgsql;

-- Grant permissions
GRANT SELECT, INSERT, UPDATE, DELETE ON app_cache TO postgres;
GRANT SELECT, INSERT, UPDATE, DELETE ON session_store TO postgres;
GRANT EXECUTE ON FUNCTION cleanup_expired_cache() TO postgres;
GRANT EXECUTE ON FUNCTION cleanup_expired_sessions() TO postgres;</code></pre>

            <h4>6. Local Testing Scripts</h4>
            <pre><code># scripts/local-test-postgres-cache.sh
#!/bin/bash

echo "🚀 Starting Local Testing Environment with PostgreSQL Caching"

# Build application
echo "📦 Building application..."
./mvnw clean package -DskipTests

# Start services
echo "🐳 Starting Docker services..."
docker-compose -f docker-compose.local.yml up -d

# Wait for services to be ready
echo "⏳ Waiting for services to be ready..."
sleep 30

# Setup PostgreSQL caching tables
echo "🗄️ Setting up PostgreSQL caching tables..."
docker-compose -f docker-compose.local.yml exec postgres psql -U postgres -d malayalees_us_site -f /docker-entrypoint-initdb.d/02-postgres-cache-setup.sql

# Run database migrations
echo "🗄️ Running database migrations..."
docker-compose -f docker-compose.local.yml exec app java -jar app.jar --spring.profiles.active=local-postgres-cache --spring.liquibase.enabled=true

# Run tests
echo "🧪 Running tests..."
./mvnw test -Ptest-local-postgres-cache

# Health check
echo "🏥 Performing health check..."
curl -f http://localhost:8080/management/health || exit 1

# Cache performance test
echo "⚡ Testing cache performance..."
curl -f http://localhost:8080/management/cache || echo "Cache endpoint not available"

echo "✅ Local environment is ready!"
echo "📊 Application: http://localhost:8080"
echo "🗄️ pgAdmin: http://localhost:5050 (admin@local.com/admin)"
echo "📈 Cache Stats: http://localhost:8080/management/cache"</code></pre>

            <h4>7. Test Data Setup</h4>
            <pre><code>-- src/main/resources/init-scripts/01-test-data.sql
-- Insert test tenants
INSERT INTO tenant_organization (id, tenant_id, organization_name, domain_name, is_active, created_at, updated_at)
VALUES
    (1, 'tenant_demo_001', 'Demo Organization 1', 'demo1.local', true, NOW(), NOW()),
    (2, 'tenant_demo_002', 'Demo Organization 2', 'demo2.local', true, NOW(), NOW()),
    (3, 'tenant_demo_003', 'Demo Organization 3', 'demo3.local', true, NOW(), NOW());

-- Insert test users
INSERT INTO user_profile (id, tenant_id, email, first_name, last_name, is_active, created_at, updated_at)
VALUES
    (1, 'tenant_demo_001', 'user1@demo1.local', 'John', 'Doe', true, NOW(), NOW()),
    (2, 'tenant_demo_002', 'user2@demo2.local', 'Jane', 'Smith', true, NOW(), NOW()),
    (3, 'tenant_demo_003', 'user3@demo3.local', 'Bob', 'Johnson', true, NOW(), NOW());

-- Insert test events
INSERT INTO event_details (id, tenant_id, title, description, event_date, created_by_id, created_at, updated_at)
VALUES
    (1, 'tenant_demo_001', 'Test Event 1', 'Test event for demo 1', NOW() + INTERVAL '7 days', 1, NOW(), NOW()),
    (2, 'tenant_demo_002', 'Test Event 2', 'Test event for demo 2', NOW() + INTERVAL '14 days', 2, NOW(), NOW());</code></pre>
        </section>

        <section id="cost-comparison">
            <h2>Performance Comparison: Redis vs PostgreSQL Caching</h2>

            <h3>Latency Comparison</h3>
            <table>
                <tr>
                    <th>Operation</th>
                    <th>Redis</th>
                    <th>PostgreSQL UNLOGGED</th>
                    <th>PostgreSQL Shared Buffers</th>
                </tr>
                <tr>
                    <td><strong>Simple Key-Value Read</strong></td>
                    <td>0.1-0.5ms</td>
                    <td>0.5-2ms</td>
                    <td>0.2-1ms</td>
                </tr>
                <tr>
                    <td><strong>Complex Query Result</strong></td>
                    <td>1-5ms</td>
                    <td>2-10ms</td>
                    <td>0.5-3ms</td>
                </tr>
                <tr>
                    <td><strong>Batch Operations</strong></td>
                    <td>0.5-2ms</td>
                    <td>1-5ms</td>
                    <td>0.5-2ms</td>
                </tr>
                <tr>
                    <td><strong>Memory Usage</strong></td>
                    <td>Dedicated</td>
                    <td>Shared with DB</td>
                    <td>Shared with DB</td>
                </tr>
            </table>

            <h3>Throughput Comparison</h3>
            <table>
                <tr>
                    <th>Metric</th>
                    <th>Redis</th>
                    <th>PostgreSQL Caching</th>
                    <th>Improvement</th>
                </tr>
                <tr>
                    <td><strong>Read Operations/sec</strong></td>
                    <td>100,000+</td>
                    <td>50,000-80,000</td>
                    <td>50-80% of Redis</td>
                </tr>
                <tr>
                    <td><strong>Write Operations/sec</strong></td>
                    <td>50,000+</td>
                    <td>20,000-40,000</td>
                    <td>40-80% of Redis</td>
                </tr>
                <tr>
                    <td><strong>Memory Efficiency</strong></td>
                    <td>High</td>
                    <td>Very High</td>
                    <td>Better resource utilization</td>
                </tr>
                <tr>
                    <td><strong>Consistency</strong></td>
                    <td>Eventual</td>
                    <td>ACID</td>
                    <td>Stronger consistency</td>
                </tr>
            </table>

            <h3>Benefits of PostgreSQL Caching</h3>
            <div class="benefits-list">
                <ul>
                    <li>✅ <strong>Simplified Architecture</strong>: Single database dependency</li>
                    <li>✅ <strong>ACID Compliance</strong>: Cache operations are transactional</li>
                    <li>✅ <strong>Better Resource Utilization</strong>: Shared memory pool</li>
                    <li>✅ <strong>Reduced Operational Overhead</strong>: No separate cache management</li>
                    <li>✅ <strong>Cost Savings</strong>: 16-18% reduction in infrastructure costs</li>
                    <li>✅ <strong>Easier Monitoring</strong>: Single point of monitoring</li>
                    <li>✅ <strong>Backup & Recovery</strong>: Cache data included in database backups</li>
                </ul>
            </div>

            <h3>When to Consider Redis</h3>
            <div class="warning-list">
                <ul>
                    <li>⚠️ <strong>High-Frequency Writes</strong>: If you need >50K writes/sec</li>
                    <li>⚠️ <strong>Complex Data Structures</strong>: Lists, sets, sorted sets</li>
                    <li>⚠️ <strong>Pub/Sub Messaging</strong>: Real-time messaging requirements</li>
                    <li>⚠️ <strong>Cross-Service Caching</strong>: Multiple services sharing cache</li>
                </ul>
            </div>

            <h2>Cost Comparison Summary</h2>
            <table>
                <tr>
                    <th>Service</th>
                    <th>EC2</th>
                    <th>Fargate</th>
                    <th>Fargate + PostgreSQL Cache</th>
                </tr>
                <tr>
                    <td><strong>Initial (1K users)</strong></td>
                    <td>$125/month</td>
                    <td>$95/month</td>
                    <td>$80/month</td>
                </tr>
                <tr>
                    <td><strong>Growth (10K users)</strong></td>
                    <td>$200/month</td>
                    <td>$165/month</td>
                    <td>$135-175/month</td>
                </tr>
                <tr>
                    <td><strong>Scale (100K users)</strong></td>
                    <td>$300-500/month</td>
                    <td>$385-585/month</td>
                    <td>$325-525/month</td>
                </tr>
                <tr>
                    <td><strong>Management Overhead</strong></td>
                    <td>High</td>
                    <td>Low</td>
                    <td>Very Low</td>
                </tr>
                <tr>
                    <td><strong>Auto-scaling</strong></td>
                    <td>Manual setup</td>
                    <td>Built-in</td>
                    <td>Built-in</td>
                </tr>
                <tr>
                    <td><strong>Learning Curve</strong></td>
                    <td>Low</td>
                    <td>Low</td>
                    <td>Low</td>
                </tr>
                <tr>
                    <td><strong>Architecture Complexity</strong></td>
                    <td>Medium</td>
                    <td>Low</td>
                    <td>Very Low</td>
                </tr>
            </table>
        </section>

        <section id="migration-strategy">
            <h2>Migration Strategy</h2>

            <div class="phase-box">
                <h4>Phase 1: Local Testing with PostgreSQL Caching (Week 1)</h4>
                <ol>
                    <li>Set up Docker Compose environment with PostgreSQL caching</li>
                    <li>Create PostgreSQL cache tables and functions</li>
                    <li>Update application configuration for PostgreSQL caching</li>
                    <li>Test all functionality locally</li>
                    <li>Validate database migrations</li>
                    <li>Test multi-tenant features</li>
                    <li>Performance testing with PostgreSQL caching</li>
                </ol>
            </div>

            <div class="phase-box">
                <h4>Phase 2: Fargate Deployment with PostgreSQL Caching (Week 2)</h4>
                <ol>
                    <li>Deploy to Fargate with PostgreSQL caching configuration</li>
                    <li>Configure RDS parameter group for optimal caching</li>
                    <li>Test auto-scaling with PostgreSQL caching</li>
                    <li>Validate monitoring and cache statistics</li>
                    <li>Performance testing and comparison with Redis</li>
                </ol>
            </div>

            <div class="phase-box">
                <h4>Phase 3: Production Optimization (Week 3)</h4>
                <ol>
                    <li>Fine-tune PostgreSQL caching parameters</li>
                    <li>Optimize database connections and pooling</li>
                    <li>Set up monitoring alerts for cache performance</li>
                    <li>Load testing with PostgreSQL caching</li>
                    <li>Implement cache cleanup automation</li>
                    <li>Document performance metrics and tuning</li>
                </ol>
            </div>

            <div class="phase-box">
                <h4>Phase 4: Redis Migration (Optional - Week 4)</h4>
                <p>If you decide to migrate from existing Redis setup:</p>
                <ol>
                    <li><strong>Parallel Running</strong>: Run both Redis and PostgreSQL caching</li>
                    <li><strong>Gradual Migration</strong>: Migrate cache types one by one</li>
                    <li><strong>Performance Monitoring</strong>: Compare performance metrics</li>
                    <li><strong>Data Migration</strong>: Migrate existing cache data if needed</li>
                    <li><strong>Redis Decommission</strong>: Remove Redis after validation</li>
                </ol>
            </div>
        </section>

        <section id="recommendation">
            <h2>Recommendation</h2>

            <div class="highlight">
                <h3>Go with Fargate + PostgreSQL Caching</h3>
                <ul>
                    <li>✅ <strong>Lower Total Cost of Ownership</strong>: No server management + 16-18% cost savings</li>
                    <li>✅ <strong>Faster Time to Market</strong>: Deploy in hours, not days</li>
                    <li>✅ <strong>Better Resource Utilization</strong>: Pay only for what you use + shared memory pool</li>
                    <li>✅ <strong>Automatic Scaling</strong>: Handles traffic spikes seamlessly</li>
                    <li>✅ <strong>Security</strong>: Isolated containers, no shared infrastructure</li>
                    <li>✅ <strong>Simplified Architecture</strong>: Single database dependency eliminates Redis complexity</li>
                    <li>✅ <strong>ACID Compliance</strong>: Cache operations are transactional and consistent</li>
                    <li>✅ <strong>Easier Monitoring</strong>: Single point of monitoring for data and cache</li>
                    <li>✅ <strong>Future-Proof</strong>: Easy migration to EKS later if needed</li>
                </ul>
            </div>

            <h3>Key Benefits of PostgreSQL Caching Approach</h3>
            <div class="benefits-list">
                <ul>
                    <li>🎯 <strong>Cost Reduction</strong>: Eliminate $15-60/month Redis costs</li>
                    <li>🎯 <strong>Operational Simplicity</strong>: No separate cache management</li>
                    <li>🎯 <strong>Better Resource Utilization</strong>: Shared memory between database and cache</li>
                    <li>🎯 <strong>Stronger Consistency</strong>: ACID-compliant cache operations</li>
                    <li>🎯 <strong>Easier Backup/Recovery</strong>: Cache data included in database backups</li>
                    <li>🎯 <strong>Reduced Complexity</strong>: One less service to monitor and maintain</li>
                </ul>
            </div>

            <p>The local testing environment with PostgreSQL caching will let you validate the performance and functionality before deploying to AWS, ensuring a smooth transition with significant cost savings.</p>
        </section>

        <div class="version-info">
            <p><em>Last Updated: January 2025</em><br>
            <em>Version: 3.0 - PostgreSQL Caching Integration</em></p>
        </div>

        <div class="summary-box">
            <h4>Summary of Changes in Version 3.0</h4>

            <h4>🆕 New Features</h4>
            <ul>
                <li><strong>PostgreSQL Built-in Caching</strong>: Complete integration guide for replacing Redis</li>
                <li><strong>UNLOGGED Tables</strong>: Fast key-value storage for application cache</li>
                <li><strong>Materialized Views</strong>: Pre-computed query results for complex operations</li>
                <li><strong>Shared Buffers Optimization</strong>: Enhanced memory configuration for caching</li>
                <li><strong>Session Management</strong>: PostgreSQL-based session storage</li>
                <li><strong>Performance Comparison</strong>: Detailed Redis vs PostgreSQL caching analysis</li>
            </ul>

            <h4>💰 Cost Improvements</h4>
            <ul>
                <li><strong>16-18% Cost Reduction</strong>: Eliminated Redis/ElastiCache dependency</li>
                <li><strong>Simplified Architecture</strong>: Single database dependency</li>
                <li><strong>Better Resource Utilization</strong>: Shared memory pool between DB and cache</li>
            </ul>

            <h4>🔧 Configuration Updates</h4>
            <ul>
                <li><strong>Updated Docker Compose</strong>: Removed Redis, added PostgreSQL caching setup</li>
                <li><strong>New Application Profiles</strong>: <code>local-postgres-cache</code> and <code>prod-aws-postgres-cache</code></li>
                <li><strong>PostgreSQL Configuration</strong>: Optimized parameters for caching performance</li>
                <li><strong>Migration Scripts</strong>: Automated setup for PostgreSQL caching tables</li>
            </ul>

            <h4>📊 Performance Analysis</h4>
            <ul>
                <li><strong>Latency Comparison</strong>: Detailed performance metrics</li>
                <li><strong>Throughput Analysis</strong>: Read/write operations comparison</li>
                <li><strong>Memory Efficiency</strong>: Better resource utilization analysis</li>
                <li><strong>Monitoring</strong>: Enhanced cache statistics and monitoring</li>
            </ul>
        </div>

        <script>
            mermaid.initialize({
                startOnLoad: true,
                theme: 'default',
                flowchart: {
                    useMaxWidth: true,
                    htmlLabels: true
                }
            });
        </script>
    </div>
</body>
</html>